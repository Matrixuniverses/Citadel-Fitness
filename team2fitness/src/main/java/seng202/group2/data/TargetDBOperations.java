package seng202.group2.data;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import seng202.group2.model.Target;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Locale;

/**
 * The TargetDBOperations is a static class handles all sql queries and methods relating specifically to the Targets relation
 * in the database.
 */
public class TargetDBOperations {


    //helper function which extracts collected Targets from a Result Set and returns them as an Observable List
    private static ObservableList<Target> getResultSetTargets(ResultSet rs) throws SQLException{

        ObservableList<Target> collectedTargets = FXCollections.observableArrayList();
        //loop through each record
        while (rs.next()) {
            int targetID = rs.getInt(1);
            String targetName = rs.getString(3);


            //Parsing date string to convert it into a java.util.Date object.
            java.util.Date targetDate = null;
            SimpleDateFormat dateFormatter = new SimpleDateFormat("EEE MMM dd HH:mm:ss zzzz yyyy", Locale.ENGLISH);

            try {
                targetDate = dateFormatter.parse(rs.getString(4));
            } catch (ParseException e) {
                System.err.println("Unable to parse date");
                e.printStackTrace();
            }
            String targetType = rs.getString(5);

            double targetInitVal = rs.getDouble(6);
            double targetCurrVal = rs.getDouble(7);
            double targetFinVal = rs.getDouble(8);

            Target newTarget = new Target(targetName, targetDate, targetType, targetInitVal, targetCurrVal, targetFinVal);
            newTarget.setId(targetID);
            collectedTargets.add(newTarget);
        }

        return collectedTargets;
    }

    /**
     *  Retrieves all targets from the database belonging to a specified user denoted by their user id.
     *  This method automatically connects to and disconnects from the database.
     * @param userID The id of the user that the targets belong to.
     * @return An Observable List containing the user's targets
     * @throws SQLException if an sql related error occurs while querying the database
     */
    public static ObservableList<Target> getAllUserTargets(int userID) throws SQLException {
        //executes a query that retrieves targets from the database with a specified user_id foreign key
        Connection dbConn = DatabaseOperations.connectToDB();
        String sqlQueryStmt = "SELECT * FROM Targets WHERE user_id = ?";
        PreparedStatement pQueryStmt = dbConn.prepareStatement(sqlQueryStmt);
        pQueryStmt.setInt(1, userID);
        ResultSet queryResult = pQueryStmt.executeQuery();

        ObservableList<Target> collectedTargets = getResultSetTargets(queryResult);

        //freeing resources
        pQueryStmt.close();
        DatabaseOperations.disconnectFromDB();
        return collectedTargets;


    }

    /**
     *  Returns a specific target from the database. Returns null if the target does not exist.
     *  This function automatically connects to and disconnects from the database.
     * @param targetID The id of the target to be retrieved from the database
     * @return The target identified by the specific target id. Null if a target is not present in the database with
     * the specified Id.
     * @throws SQLException if an sql related error occurs while querying the database
     */
    public static Target getTargetFromDB(int targetID) throws SQLException {

        //executes a query that retrieves a target from the database with a specified id.
        Connection dbConn = DatabaseOperations.connectToDB();
        String sqlQueryStmt = "SELECT * FROM Targets WHERE target_id = ?";
        PreparedStatement pQueryStmt = dbConn.prepareStatement(sqlQueryStmt);
        pQueryStmt.setInt(1, targetID);
        ResultSet queryResult = pQueryStmt.executeQuery();

        Target collectedTarget = null;
        ObservableList<Target> collectedTargetList = getResultSetTargets(queryResult);

        //if the collected target list is not empty then the target has been successfully retrieved from the database
        //and we can extract it.
        if (!(collectedTargetList.isEmpty())) {
            collectedTarget = collectedTargetList.get(0);
        }

        //freeing resources
        pQueryStmt.close();
        DatabaseOperations.disconnectFromDB();
        return collectedTarget;
    }

    /**
     * Inserts a new target object into the database for a specified User. Returned value is the target id which is the
     * public key generated by the database. If the specified user does not exist within the database an error value of
     * -1 is returned by the function.
     * This function automatically connects to and disconnects from the database
     * @param target The target object to be inserted into the database.
     * @param userID The id of the User that the target belongs to as an Integer.
     * @return The primary key of the target if the inserted user id is valid. -1 otherwise.
     * @throws SQLException If an sql related error occurs when preforming query and insert statements on the database.
     */
    public static int insertNewTarget(Target target, int userID) throws SQLException {

        //check whether the user identified by their userId is in the database
        if (UserDBOperations.getUserFromDB(userID) == null) {
            return -1;
        }

        Connection dbConn = DatabaseOperations.connectToDB();
        String sqlInsertStmt = "INSERT INTO Targets(user_id, name, date_achieved, type, initial_value, current_value, final_value) VALUES (?,?,?,?,?,?,?)";

        // Execute prepared statement
        PreparedStatement pUpdateStmt = dbConn.prepareStatement(sqlInsertStmt);
        pUpdateStmt.setInt(1, userID);
        pUpdateStmt.setString(2, target.getName());
        pUpdateStmt.setString(3, target.getCompletionDate().toString());
        pUpdateStmt.setString(4, target.getType());
        pUpdateStmt.setDouble(5, target.getInitialValue());
        pUpdateStmt.setDouble(6, target.getCurrentValue());
        pUpdateStmt.setDouble(7, target.getFinalValue());
        pUpdateStmt.executeUpdate();

        //retrieves the generated primary keys
        ResultSet genKeysRS = pUpdateStmt.getGeneratedKeys();
        genKeysRS.next();

        int targetID = genKeysRS.getInt(1);


        //freeing resources
        pUpdateStmt.close();
        DatabaseOperations.disconnectFromDB();
        return targetID;
    }

    /**
     * Updates a target that is present in the database. Takes the updated object as a parameter. The method returns true if the
     * record in the database is successfully updated. Else if the target does not already in the database the method
     * will return the value false.
     * This method automatically connects to and disconnects from the database.
     * @param target The updated target object that will have its corresponding record updated in the database.
     * @return True if the sql update operation is completed successfully. False if the target's record does not exist in
     * the database.
     * @throws SQLException If an sql related error occurs when preforming query and update statements on the database.
     */
    public static boolean updateExistingTarget(Target target) throws SQLException {

        String sqlUpdateStmt = "UPDATE Targets SET name = ?, date_achieved = ?, type = ?, initial_value = ?, current_value = ?, final_value = ? WHERE target_id = ?";

        //Checking if the Target exists in the database
        if (getTargetFromDB(target.getId()) != null) {

            Connection dbConn = DatabaseOperations.connectToDB();

            // Execute prepared statement
            PreparedStatement pUpdateStmt = dbConn.prepareStatement(sqlUpdateStmt);
            pUpdateStmt.setString(1, target.getName());
            pUpdateStmt.setString(2, target.getCompletionDate().toString());
            pUpdateStmt.setString(3, target.getType());
            pUpdateStmt.setDouble(4, target.getInitialValue());
            pUpdateStmt.setDouble(5, target.getCurrentValue());
            pUpdateStmt.setDouble(6, target.getFinalValue());
            pUpdateStmt.setInt(7, target.getId());
            pUpdateStmt.executeUpdate();

            //freeing resources
            pUpdateStmt.close();
            DatabaseOperations.disconnectFromDB();

            return true;

        } else {

            return false;
        }
    }


    /**
     * Deletes activity in the database with the given target ID.
     * This method automatically connects to and disconnects from the database.
     * @param targetID targetID of the target to be deleted
     * @return True if activity to delete exists in database and has been deleted, False otherwise
     * @throws SQLException If unable to read/ write from/ to database
     */
    public static boolean deleteExistingTarget(int targetID) throws SQLException {

        Connection dbConn = DatabaseOperations.connectToDB();

        String sqlDeleteStmt = "DELETE FROM Targets WHERE target_id = ?";

        // Execute prepared statement
        PreparedStatement pDeleteStmt = dbConn.prepareStatement(sqlDeleteStmt);
        pDeleteStmt.setInt(1, targetID);
        pDeleteStmt.executeUpdate();

        //disconnect from the database
        DatabaseOperations.disconnectFromDB();

        return (getTargetFromDB(targetID) == null);
    }





}
